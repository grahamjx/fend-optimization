{
  "name": "Website Optimization",
  "tagline": "Front-End Nanodegree Project #4",
  "body": "####Part 1: Optimize PageSpeed Insights Score for index.html\r\n\r\nThe goal for this part of the project is to optimize the provided index.html so that it receives a score of 90 or higher using PageSpeed Insights\r\n\r\n1. Run gulp from project directory\r\n   \r\n    `$ gulp serve`\r\n  \r\n2. Open a browser and visit localhost:8000\r\n\r\n3. Copy the public URL ngrok gives you in the console and try running it through [PageSpeed Insights!](https://developers.google.com/speed/pagespeed/insights/)\r\n\r\n####Part 2: Optimize Frames per Second in pizza.html\r\n\r\nThe pizzeria site should be optimized to run at 60FPS while scrolling. In addition, changing the pizza size should not cause the browser to freeze and produce any noticeable 'jank'.\r\n\r\n* __Problem 1: updatePositions__\r\n\r\n      The first major problem was that the browser was taking way to long to animate the frames\r\n      when scrolling with the app. As you scroll, the small pizzas move in a sudo-random pattern.\r\n      I changed the total number of pizzas (TOTAL_PIZZA) to render on load.\r\n      \r\n      After examining the for loop using console.log, you can see a pattern in the output.\r\n      Specifically in the original modulus operation (i % 5). So I pulled the Math.sin\r\n      call out of the original loop and pushed the new values into an array to hold each\r\n      of these five values.\r\n\r\n      ```\r\n      var items = document.getElementsByClassName('mover'); //grabs all the small pizza elements\r\n            var phase = [];\r\n\r\n      for (var i = 0; i < 5; i++) {\r\n            phase.push(Math.sin((scrollLocation / 1250)+i)); //stores the new values in the array\r\n      }\r\n      ```\r\n      \r\n      Finally, I iterate though all the pizzas stored in items and update their style accordingly.\r\n\r\n      ```\r\n      for (var i = 0; i < TOTAL_PIZZA; i++) {\r\n            items[i].style.left = items[i].basicLeft + 100 * phase[i%5] + 'px'; //adjust styles\r\n      }\r\n      ```\r\n* __Problem 2: resizePizzas__\r\n\r\n      Through a series of tests using console.log and trial and error, I was able to\r\n      identify more patterns in the way the elements were being modified. oldSize\r\n      was originally being calculated using calls to an elements offsetWidth property.\r\n      This causes re-flow issues and various perfomance problems. Eventually, it can be\r\n      simplified that the PIZZA_WIDTH (offsetWidth value) doesn't actually change\r\n      once the elements are added to the DOM on page load. Since the size starts\r\n      at set point, you can log that value and use it as a constant.\r\n      \r\n      ```\r\n      function determineDx (size) {\r\n        var newSize = 0;\r\n          switch (size) {\r\n            case \"1\":\r\n              return newSize = ((0.25 - OLD_SIZE) * PIZZA_WIDTH) + PIZZA_WIDTH + 'px';\r\n            case \"2\":\r\n              return newSize = ((0.3333 - OLD_SIZE) * PIZZA_WIDTH) + PIZZA_WIDTH + 'px';\r\n            case \"3\":\r\n              return newSize = ((0.5 - OLD_SIZE) * PIZZA_WIDTH) + PIZZA_WIDTH + 'px';\r\n            default:\r\n              console.log(\"bug in sizeSwitcher\");\r\n            }\r\n      }\r\n      ```\r\n     Since most of the \"heavily lifting\" is done by determineDx, this\r\n     function simply grabs the newWidth and the iterates through the pizzaBox array\r\n     adjusting the style accordingly.\r\n     \r\n     ```\r\n     function changePizzaSizes(size) {\r\n         var newWidth = determineDx(size);\r\n         for (var i = 0; i < PIZZA_BOX_SIZE; i++) {\r\n            pizzaBox[i].style.width = newWidth;\r\n         }\r\n      }\r\n      ```\r\nAll of the times(ms) can be seen in the console using dev-tools",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}